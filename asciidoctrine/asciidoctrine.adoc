ASCIIdoctrine
=============
Benjamin Kober <benko@kober-systems.com>
:toc: left
// In diesem Dokument wird der ganze Quelltext angezeigt.
:code:

Eine asciidoc Implementierung in rust.

ASCIIdoctrine will möglichst kompatibel zur asciidoc Interpretation von http://asciidoctor.org[asciidoctor] sein, so dass es als Drop-in Ersatz genutzt werden kann. Allerdings ist es in https://www.rust-lang.org/[rust] geschrieben und hat das Ziel flexibeler und leichter zu portieren zu sein.

== Einstieg
Je nach Interessenlage und Beweggrund zum lesen dieses Artikels wird man
unterschiedlich an ihn herangehen.

* Will man einfach Texte mit `asciidoc` Markup verfassen sollte man zum
  <<asciidoc-syntax, ASCIIdoc Syntax>> Abschnitt gehen oder zur Beschreibung
  der <<cmd-api, Kommandozeilenparameter>>.
* Will man wissen wie das Programm funktioniert oder es anpassen kann man
  einfach weiterlesen.

== Übersicht
Dieses Programm ist im https://en.wikipedia.org/wiki/Literate_programming[literate programming] Stil geschrieben. Gie Grundidee ist eine ASCIIdoc Benutzeranleitung so umzuarbeiten, dass sie sich automatisch zu einem ausführbaren Programm mit Tests kompilieren lässt.

Dazu verwenden wir https://lammermann.github.io/literate_programming_toolsuite/lisa/lisa.html[lisa] (welches im gleichen Repo verwaltet wird) als Werkzeug.

=== Motivation und Hintergrund
Das Programm http://jgm.github.io/lunamark/doc/lunamark.html[lunamark] hat
ursprünglich mein Interesse für http://www.lua.org[lua],
http://www.inf.puc-rio.br/~roberto/lpeg/[lpeg] und die Implementierung von
Parsern im Allgemeinen geweckt. Ich war begeistert wie der Eingabetext mit
Mustern abgesucht und umgewandelt wurde (vorher kannte ich nur
https://en.wikipedia.org/wiki/Regular_expression[regular expressions] und wäre
bei solch komplexen Aufgaben sofort an Grenzen gestoßen).

Ich fing an einen asciidoc parser für lunamark zu schreiben. Nach einiger Zeit
stellten sich ein paar Probleme heraus:

* lunamark ist für https://daringfireball.net/projects/markdown/[markdown]
  geschrieben und das ist nicht für beliebig komplexe Dokumente geeignet.
* Der Eingabetext wird sofort in das Ausgabeformat umgewandelt und nicht in
  einen https://en.wikipedia.org/wiki/Abstract_syntax_tree[AST].

Das zweite Problem ist in meinem Fall problematischer als das erste, da ich das Werkzeug nicht nur benutzen will um Dokumente zu erstellen. Hat man einen AST kann man nach belieben filtern, umsortieren, bearbeiten und in völlig andere Formate einbauen.

=== Programmarchitektur
Aus diesem Grund soll dieses Programm mehrschrittig vorgehen und alle Dateien
zunächst in einen AST umwandeln:

[[dataflow-outline]]
[ditaa]
.Module und Datenstrom in asciidoctrine
----

                         /-/-------------\                   /-/-----------\
                         | |             |                   | |           |
                         | | Steuerungs- +-=----+            | | Styles    +------+
                         | | dateien ... |      |            | | (css,...) |      |
                         \-\-------------/      |            \-\-----------/      |
                                                v                                 v
  /----------\   +--------+   /-----\   +---------------+   /-----\   +------------------+   /----------------\
  |          |   | {io}   |   |     |   | {io}          |   |     |   | {io}             |   |                |
  | Eingabe- +-->| Reader +-->| AST +-->| Erweiterungen +-->| AST +-->| Output Processor |-->| Ausgabedateien |
  | Datei    |   |        |   |     |   | ...           |   |     |   | (Writer)         |   | (html,pdf,...) |
  \----------/   +--------+   \-----/   +------+--+-----+   \-----/   +------------------+   \----------------/
                                 ^             |  :
                                 |     ...     |  |   /----------------\-\
                                 +-=-----------+  |   | optionale      | |
                                                  +-->| Ausgabedateien | |
                                                      | (png,svg,...)  | |
                                                      \----------------/-/

----

So kann man einerseits leicht unterschiedliche <<generate-output, Ausgabeformate>> unterstützen und andererseits eine <<api>> zur Verfügung stellen, die Zugriff auf die gesamte Dokumentstruktur gibt.

Der generelle Ablauf ist folgendermaßen:

Die Eingabedatei(en) wird(werden) eingelesen::
  * Diese wird von einem <<reader>> eingelesen und in einen AST umgewandelt.
  * Der <<reader>> wird nur einmal ausgewählt und ist (im Fall von mehreren
    Eingabedateien) für alle Eingabedateien gleich.
  * Das standardmäßige Eingabeformat ist <<asciidoc-syntax>>.
Der AST wird von einer oder mehreren Erweiterungen modifiziert::
  * Jede <<extensions, Erweiterung>> bekommt einen AST als Parameter übergeben
    und gibt einen AST zurück.
  * Erweiterungen können über die <<cmd-api, Kommandozeile>> oder die <<api>>
    weitere Parameter und Steuerungsdateien (von beliebigem Format) übergeben
    werden.
  * Es können beliebig viele Erweiterungen in beliebiger Reihenfolge
    hintereinander geschaltet werden.
  * Ob eine Erweiterung eigene Ausgabedateien erzeugt, bleibt ihr selbst
    überlassen.
  * Standardmäßig sind keine Erweiterungen aktiviert.
Ein Output Prozessor (Writer) wandelt den AST in eine Ausgabedatei um::
  * Der Writer kann über die <<cmd-api, Kommandozeile>> oder die <<api>> Parameter
    oder Styledateien (wie css-Stylesheets etc) übergeben bekommen.
  * Das standardmäßige Ausgabeformat ist <<html5>>.

== Implementierung
`asciidoctrine` ist ein rust Programm. Der Hauptteil des Programms ist in einer
Bibliothek implementiert. Ein kleiner Teil ist ein Kommandozeilenprogramm
welches diese Bibliothek benutzt und die Parameter übergibt.

[source, rust, save]
.src/lib.rs
----
<<crate_usages>>

<<internal_modules>>

<<public_structs>>

<<interfaces|join="\n\n">>
----

Die Bibliothek wiederum teilt den Großteil ihrer Aufgaben einigen abgetrennten
Modulen zu:

[[internal_modules]]
[source, rust]
.Module innerhalb des crates
----
mod ast;         // <1>
pub use ast::*;
pub mod options;
pub mod util;
pub mod reader;
pub use reader::asciidoc::AsciidocReader;
pub use reader::json::JsonReader;
mod writer;
pub use writer::html::HtmlWriter;
pub use writer::docx::DocxWriter;
pub use writer::json::JsonWriter;
----
<1> `ast` definiert das allgemeine Zwischenformat für alle Dokumente.

[[public_structs]]
[source, rust]
.Fehlerbehandlung
----
#[derive(Error, Debug)]
pub enum AsciidoctrineError {
  #[error("could not parse input")]
  Parse(#[from] pest::error::Error<reader::asciidoc::Rule>),
  #[error(transparent)]
  Json(#[from] serde_json::Error),
  #[error(transparent)]
  Io(#[from] std::io::Error),
  #[error(transparent)]
  BufWriter(#[from] io::IntoInnerError<io::BufWriter<Vec<u8>>>),
  #[error(transparent)]
  Template(#[from] tera::Error),
  #[error(transparent)]
  Utf8(#[from] std::str::Utf8Error),
  #[error(transparent)]
  Docx(#[from] docx_rs::DocxError),
  #[error("Child process stdin has not been captured!")]
  Childprocess,
  #[error("malformed ast structure")]
  MalformedAst,
}

type Result<T> = std::result::Result<T, AsciidoctrineError>;
----

[[crate_usages]]
[source, rust]
----
extern crate pest;
#[macro_use]
extern crate pest_derive;

use std::io;
use thiserror::Error;
----

[[input-format]]
=== Eingabeformate

[source, rust, save]
.src/reader/mod.rs
----
pub mod asciidoc;
pub mod json;
----

:leveloffset: +3

[[asciidoc-syntax]]
include::asciidoc-syntax.adoc[]

= Asciidoc
Asciidoc ist ein einfaches Text Markup Format.

Wir verwenden https://pest.rs/[pest] um die Syntax zu parsen. Es verwendet https://pest.rs/book/grammars/peg.html[Parsing Expression Grammars] um Daten zu parsen.

TODO TOML Eintrag

Die grundlegende Syntax definieren wir in einer eigenen Datei welche wir in unserer PEG DSL schreiben.

[%collapsible]
====
[source, rust, save]
.src/reader/asciidoc.pest
----
<<basic_document_structure>>

<<blocks|join="\n\n">>

////////////////////////////////////////////////////////////////////////////////
// often resused elements

<<peg_building_blocks>>

////////////////////////////////////////////////////////////////////////////////
// inline elements

inline = {
  !empty_lines ~ !EOI ~
  ( comment |
    link |
    strong |
    emphasized |
    monospaced |
    quoted |
    footnote |
    footnoteref |
    xref
  )
}
other_inline = @{ (!empty_lines ~ !EOI ~ !inline ~ ANY)+ }

<<inline_elements|join="\n\n">>

////////////////////////////////////////////////////////////////////////////////
// generics

<<generic_pegs|join="\n\n">>

////////////////////////////////////////////////////////////////////////////////

// Implicit whitespace rule
WHITESPACE = _{ " " | "\t" }
----

Damit können wir die Syntax in einer relativ formalen Sprache definieren welche das parsen erleichtert. Diesem, noch eher groben AST, weisen wir dann eine semantische Bedeutung zu. Den Code dazu definieren wir in einem eigenen Rust Modul mit dem Namen `asciidoc.rs`.

[source, rust, save]
.src/reader/asciidoc.rs
----
pub use crate::ast::*;
use crate::options::Opts;
use crate::util::{Env, Environment};
use crate::reader::*;
use crate::Result;
use pest::iterators::Pair;
use pest::Parser;

pub struct AsciidocReader {}

impl AsciidocReader {
  pub fn new() -> Self {
    AsciidocReader {}
  }
}

impl crate::Reader for AsciidocReader {
  fn parse<'a>(&self, input: &'a str, args: &Opts, env: &mut Env) -> Result<AST<'a>> {
    let ast = AsciidocParser::parse(Rule::asciidoc, input)?;

    let mut attributes = Vec::new();
    if let Some(path) = &args.input {
      if let Some(path) = path.to_str() {
        attributes.push(Attribute {
          key: "source".to_string(),
          value: AttributeValue::String(path.to_string()),
        });
      }
    }

    let mut elements = Vec::new();

    for element in ast {
      if let Some(element) = process_element(element, env) {
        elements.push(element);
      }
    }

    Ok(AST {
      content: input,
      elements,
      attributes,
    })
  }
}

#[derive(Parser, Debug, Copy, Clone)]
#[grammar = "reader/asciidoc.pest"]
pub struct AsciidocParser;

fn process_element<'a>(
  element: Pair<'a, asciidoc::Rule>,
  env: &mut Env,
) -> Option<ElementSpan<'a>> {
  let mut base = set_span(&element);

  let element = match element.as_rule() {
    <<asciidoc_element_rules>>
    Rule::block => {
      for subelement in element.into_inner() {
        if let Some(e) = process_element(subelement, env) {
          base = e;
        }
      }
      Some(base)
    }
    Rule::inline => Some(process_inline(element, base)),
    Rule::EOI => None,
    _ => Some(base),
  };

  element
}

<<asciidoc_parser_functions|join="\n\n">>

// Helper functions

fn concat_elements<'a>(
  element: Pair<'a, asciidoc::Rule>,
  filter: asciidoc::Rule,
  join: &str,
) -> Option<String> {
  let elements: Vec<_> = element
    .into_inner()
    .filter(|e| e.as_rule() == filter)
    .map(|e| e.as_str())
    .collect();

  if elements.len() > 0 {
    Some(elements.join(join))
  } else {
    None
  }
}

fn set_span<'a>(element: &Pair<'a, asciidoc::Rule>) -> ElementSpan<'a> {
  from_element(
    element,
    Element::Error(format!("Not implemented:{:?}", element)),
  )
}

fn from_element<'a>(rule: &Pair<'a, asciidoc::Rule>, element: Element<'a>) -> ElementSpan<'a> {
  let (start_line, start_col) = rule.as_span().start_pos().line_col();
  let (end_line, end_col) = rule.as_span().end_pos().line_col();

  ElementSpan {
    element,
    source: None, // TODO
    content: rule.as_str(),
    children: Vec::new(),
    attributes: Vec::new(),
    positional_attributes: Vec::new(),
    start: rule.as_span().start(),
    end: rule.as_span().end(),
    start_line,
    start_col,
    end_line,
    end_col,
  }
}
----
====

== Grundlegender Aufbau eines Asciidoc Dokuments
Asciidoc interpretiert einen Text als eine Sammlung von Blöcken,
welche durch Leerzeilen getrennt sind. Wenn irgendein Text nicht als
ein anderer Block interpretiert werden kann, so wird er als Paragraph
interpretiert. Dadurch ist jedes Text-Dokument eine valide Asciidoc
Datei.

[[basic_document_structure]]
[source, rust]
----
asciidoc = _{ (NEWLINE* ~ block)*  ~ NEWLINE* ~ EOI }

block = {
  <<block_entries>>
  // admonition |
  // example |
  // fenced |
  // listing |
  // literal |
  // open |
  // passthrough |
  // quote |
  // sidebar |
  // source |
  // stem |
  // table |
  // verse |
  image_block |
  include_macro |
  list |
  attribute_entry_block |
  // Title is nearly the last because it could prevent correct match of others
  title_block |
  // paragraph is the last because all others should be checked first
  paragraph |
  (!EOI ~ ANY)+
}
----

=== Wichtige Konzepte
Einige Elemente sind in ASCIIdoc wiederkehrend und können in
verschiedenen Kontexten verwendet werden. Die wichtigsten von ihnen
gehen wir jetzt durch.

TODO Attribut Listen etc

==== Elemente
TODO

==== Anker
Oft möchte man Blöcke, Absätze etc referenzieren um sich später darauf
zu beziehen. Asciidoc stellt dafür Anker zur Verfügung. Grundlegend sind
es einfach Identifier (also Namen), welche man in `[[` und `]]` einrahmt
und vor das entsprechende Element bzw vor den Block stellt.

[[peg_building_blocks]]
[source, pest]
----
anchor = { inline_anchor ~ NEWLINE }
inline_anchor = { "[[" ~ (identifier | path) ~ "]]" }
----

[%collapsible]
====
[[asciidoc_parser_functions]]
[source, rust]
----
fn process_anchor<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::inline_anchor => {
        base = process_inline_anchor(element, base);
      }
      _ => (),
    };
  }
  base
}

fn process_inline_anchor<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::identifier => {
        base.attributes.push(Attribute {
          key: "anchor".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      // TODO Fehler abfangen und anzeigen
      _ => (),
    }
  }
  base
}
----
====

==== Attribute
Man kann jedem Element Eigenschaften (Attribute) zuordnen. Diese können
beispielsweise später verwendet werden um beim rendern bestimmte Styles
anzuwenden.

Um einem Element Attribute zuzuordnen rahmt man die Liste der Attribute
in `[` und `]` und stellt sie dem Element bzw Block vorran.

[[peg_building_blocks]]
[source, pest]
.Element Attribute
----
attribute_list = { inline_attribute_list ~ NEWLINE }

inline_attribute_list = {
  "[" ~ (attribute ~ ("," ~ attribute)* )? ~ "]"
}

----

Grundsätzlich gibt es zwei Arten von Attributen: Benannte und
Unbenannte.

Unbenannte Attribute werden einfach ein oder abgeschaltet. Deshalb
ist es nicht nötig, ihnen einen Wert zuzuweisen. Wenn sie in der
Attributliste auftauchen, sind sie automatisch eingeschaltet.

Benannte Attribute können unterschiedliche Werte annehmen. Deshalb
bekommen sie einen Namen, an den ein Wert übergeben wird, namch dem
Schema `name=wert`.

[[peg_building_blocks]]
[source, pest]
----
attribute = { named_attribute | attribute_value }
named_attribute = { identifier ~ "=" ~ attribute_value }
attribute_value = {
  ("\"" ~ inner_attribute_value ~ "\"") |
  ( (!"," ~ !"]" ~ ANY)+ )
}
inner_attribute_value = { ( "\\\"" | (!"\"" ~ ANY))* }
----

[%collapsible]
====
[[asciidoc_parser_functions]]
[source, rust]
----
fn process_inline_attribute_list<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::attribute => {
        for subelement in subelement.into_inner() {
          match subelement.as_rule() {
            Rule::attribute_value => {
              // TODO Wir müssen unterschiedlich damit umgehen, ob ein oder mehrere
              // identifier existieren
              base
                .positional_attributes
                .push(AttributeValue::Ref(subelement.as_str()));
            }
            Rule::named_attribute => {
              let mut key = None;
              let mut value = None;

              for subelement in subelement.into_inner() {
                match subelement.as_rule() {
                  Rule::identifier => key = Some(subelement.as_str()),
                  Rule::attribute_value => {
                    value = Some(subelement.into_inner().concat());
                  }
                  // TODO Fehler abfangen und anzeigen
                  _ => (),
                }
              }

              base.attributes.push(Attribute {
                key: key.unwrap().to_string(),
                value: AttributeValue::String(value.unwrap()),
              });
            }
            // TODO Fehler abfangen und anzeigen
            _ => (),
          }
        }
      }
      // TODO Fehler abfangen und anzeigen
      _ => (),
    }
  }
  base
}

fn process_attribute_list<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::inline_attribute_list => {
        base = process_inline_attribute_list(element, base);
      }
      _ => (),
    };
  }
  base
}
----
====

==== Blocktitel (Elementtitel)
Blöcke haben oft ihre eigenen Titel. In Asciidoc werden sie durch eine
Zeile vor dem Block gekennzeichnet, welche mit einem `.` beginnt.

[[peg_building_blocks]]
[source, pest]
----
blocktitle = { "." ~ !"." ~ line ~ NEWLINE }
----

[%collapsible]
====

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_blocktitle<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::line => {
        base.attributes.push(Attribute {
          key: "title".to_string(), // TODO
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      _ => (),
    };
  }
  base
}
----

====

==== Abgetrennte Blöcke
Ein sehr häufig genutztes Element sind abgetrennte Blöcke. Sie erlauben
einen Text in einem speziellen Style hervorzuheben.

Der generelle Aufbau ist folgender:

[[delimited_block_template]]
[source, pest]
----
delimited_<<blocktype>> = {
  PUSH("<<delimiter>>"{4,}) ~ NEWLINE ~
  delimited_inner ~
  NEWLINE ~ POP ~ &(NEWLINE | EOI)
}
----

[%collapsible]
====

[[block_entries]]
[source, pest]
----
delimited_block |
----

[[blocks]]
[source, pest]
----
delimited_block = {
  (anchor | attribute_list | blocktitle)* ~
  (
    //delimited_admonition |
    delimited_comment |
    delimited_example |
    //delimited_fenced |
    //delimited_listing |
    delimited_literal |
    //delimited_open |
    //delimited_passthrough |
    //delimited_quote |
    //delimited_sidebar |
    delimited_source |
    //delimited_stem |
    delimited_table |
    delimited_verse
  )
}

delimited_inner = @{ (!(NEWLINE ~ PEEK) ~ ANY)* }
----

[[asciidoc_element_rules]]
[source, rust]
----
Rule::delimited_block => Some(process_delimited_block(element, env)),
----

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_delimited_block<'a>(
  element: Pair<'a, asciidoc::Rule>,
  env: &mut Env,
) -> ElementSpan<'a> {
  let mut base = set_span(&element);

  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::anchor => {
        base = process_anchor(subelement, base);
      }
      Rule::attribute_list => {
        base = process_attribute_list(subelement, base);
      }
      Rule::blocktitle => {
        base = process_blocktitle(subelement, base);
      }
      <<delimited_block_rules>>
      // We just take the attributes at the beginning
      // of the element.
      _ => {
        break;
      } // TODO improve matching
    }
  }

  base
}

fn process_delimited_inner<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
  env: &mut Env,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::delimited_inner => {
        if let Element::TypedBlock { kind: BlockType::Example } = base.element {
          let ast = AsciidocParser::parse(Rule::asciidoc, element.as_str()).unwrap();

          for element in ast {
            if let Some(e) = process_element(element, env) {
              base.children.push(e);
            }
          }
        }
        base.attributes.push(Attribute {
          key: "content".to_string(), // TODO
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      _ => (),
    };
  }
  base
}
----

====

== Document Header
Viele Dokumente beginnen mit einem Header. Es ist die Hauptüberschrift
und kann optional noch einige Metadaten enthalten welche sich auf das
ganze Doument beziehen.

[[block_entries]]
[source, pest]
----
header |
----

[[blocks]]
[source, pest]
----
header = {
  title ~
  (NEWLINE ~ author_info)? ~
  (NEWLINE ~ revision_info)? ~
  ( (NEWLINE ~ attribute_entry) |
    (NEWLINE ~ "//" ~ (!EOI ~ !NEWLINE ~ ANY)* ~ &NEWLINE ) // TODO Comment entfernen
  )*
  ~ &NEWLINE{2,}
}
----

[[blocks]]
[source, pest]
----
revision_info = { identifier } // TODO

author_info = { word+ ~ email? ~ &NEWLINE }

email = { "<" ~ (LETTER | "." )+ ~ "@" ~ (LETTER | "." )+ ~ ">" }
----

[[asciidoc_element_rules]]
[source, rust]
----
Rule::header => {
  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::title => {
        if let Some(e) = process_title(subelement, base.clone()) {
          base = e;
        }
      }
      // We just take the attributes at the beginning
      // of the element.
      _ => {
        break;
      } // TODO improve matching
    }
  }
  // TODO
  Some(base)
}
----

== Überschriften
Überschriften werden verwendet um das Dokument in Unterthemen zu gruppieren.

[[blocks]]
[source, pest]
----
title_block = { anchor* ~ title }
title = {
  (line ~ NEWLINE ~ setext_title_style ) |
  (atx_title_style ~ line)
}
setext_title_style = { ("="{4,} | "-"{4,} | "~"{4,} | "^"{4,} ) ~ &NEWLINE }
atx_title_style = { "="+ }
----

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::title => process_title(element, base),
Rule::title_block => {
  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::title => {
        if let Some(e) = process_title(subelement, base.clone()) {
          base = e;
        }
      }
      Rule::anchor => {
        base = process_anchor(subelement, base);
      }
      // We just take the attributes at the beginning
      // of the element.
      _ => {
        break;
      } // TODO improve matching
    }
  }
  Some(base)
}
----

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_title<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> Option<ElementSpan<'a>> {
  match element.as_rule() {
    Rule::title => {
      for subelement in element.into_inner() {
        match subelement.as_rule() {
          Rule::atx_title_style => {
            base.element = Element::Title {
              level: subelement.as_str().trim().len() as u32,
            };
          }
          Rule::setext_title_style => {
            let ch = subelement.as_str().chars().next().unwrap(); // TODO Check None?
            let level;

            match ch {
              '=' => {
                level = 1;
              }
              '-' => {
                level = 2;
              }
              '~' => {
                level = 3;
              }
              '^' => {
                level = 4;
              }
              _ => {
                base.element = Element::Error("Unsupported title formatting".to_string());
                break;
              }
            }
            base.element = Element::Title {
              level: level as u32,
            };
          }
          Rule::line => {
            base.attributes.push(Attribute {
              key: "name".to_string(),
              value: AttributeValue::Ref(subelement.as_str()),
            });
          }
          // We just take the attributes at the beginning
          // of the element.
          _ => {
            break; // TODO Error
          } // TODO improve matching
        }
      }
    }
    _ => (),
  };

  Some(base)
}
----

====

[cols="a,a"]
|====

[[unittest_header_setext_input]]
[source, asciidoc, lisa-raw]
[output="setext_header_html_output", name="setext_headers"]
....
This is a header
================

This is a subheader
-------------------

This is a subsubheader
~~~~~~~~~~~~~~~~~~~~~~

This is a subsubsubheader
^^^^^^^^^^^^^^^^^^^^^^^^^
....

|

This is a header
================

This is a subheader
-------------------

This is a subsubheader
~~~~~~~~~~~~~~~~~~~~~~

This is a subsubsubheader
^^^^^^^^^^^^^^^^^^^^^^^^^

[%collapsible]
.Html Output
====

[[setext_header_html_output]]
[source, html]
----
<h1>This is a header</h1>
<h2 id="_this_is_a_subheader">This is a subheader</h2>
<h3 id="_this_is_a_subsubheader">This is a subsubheader</h3>
<h4 id="_this_is_a_subsubsubheader">This is a subsubsubheader</h4>
----
====

|
Auch Titel im ATX Format werden erkannt.

[[unittest_header_atx_input]]
[source, asciidoc, lisa-raw]
[output="atx_header_html_output", name="atx_headers"]
....
= This is a header

== This is a subheader

=== This is a subsubheader

==== This is a subsubsubheader
....

|

= This is a header

== This is a subheader

=== This is a subsubheader

==== This is a subsubsubheader

[%collapsible]
.Html Output
====

[[atx_header_html_output]]
[source, html]
----
<h1>This is a header</h1>
<h2 id="_this_is_a_subheader">This is a subheader</h2>
<h3 id="_this_is_a_subsubheader">This is a subsubheader</h3>
<h4 id="_this_is_a_subsubsubheader">This is a subsubsubheader</h4>
----
====

|====

== Absätze
Absätze sind die meistgenutzen Elemente in Texten. Ihre Verwendung
ergibt sich ganz natürlich. Alles was an einem Stück geschrieben wurde
(und kein anderer Block ist) ist ein Absatz. Absätze werden durch eine
oder mehrere Leerzeilen getrennt.

[[blocks]]
[source, pest]
----
paragraph = ${ (inline | other_inline)+ }
----

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::paragraph => Some(process_paragraph(element)),
----

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_paragraph<'a>(element: Pair<'a, asciidoc::Rule>) -> ElementSpan<'a> {
  let mut base = from_element(&element, Element::Paragraph);

  for subelement in element.into_inner() {
    base.children.push(match subelement.as_rule() {
      Rule::other_inline | Rule::other_list_inline => from_element(&subelement, Element::Text),
      Rule::inline => process_inline(subelement.clone(), set_span(&subelement)),
      _ => set_span(&subelement),
    });
  }

  base
}
----

====

== Textformattierung
Innerhalb von Blöcken will man oft Texte vormattieren. Folgende
Formatierungen werden unterstützt:

[cols="a,a"]
|====

*Fett*

[[unittest_inline_bold_input]]
[source, asciidoc, lisa-raw]
[output="inline_bold_html_output", name="inline_bold"]
....
Some text is *bold*.
....

[%collapsible]
====
[[inline_elements]]
[source, pest]
----
strong = ${ "*" ~ (!"*" ~ linechar)+ ~ "*" }
----
====

|

Some text is *bold*.

[%collapsible]
.Html Output
====

[[inline_bold_html_output]]
[source, html]
----
<p>Some text is <strong>bold</strong>.</p>
----

====

|

_Kursiv_

[[unittest_inline_italic_input]]
[source, asciidoc, lisa-raw]
[output="inline_italic_html_output", name="inline_italic"]
....
Some text is _italic_.
....


[%collapsible]
====
[[inline_elements]]
[source, pest]
----
emphasized = ${ "_" ~ (!"_" ~ linechar)+ ~ "_" }
----
====

|

Some text is _italic_.

[%collapsible]
.Html Output
====

[[inline_italic_html_output]]
[source, html]
----
<p>Some text is <em>italic</em>.</p>
----

====

|
`Monospaced`

[[unittest_inline_monospaced_input]]
[source, asciidoc, lisa-raw]
[output="inline_monospaced_html_output", name="inline_monospaced"]
....
Some text is `monospaced`.
....

[%collapsible]
====
[[inline_elements]]
[source, pest]
----
monospaced = ${ inline_anchor* ~ (("+" ~ (!"+" ~ linechar)+ ~ "+") | ("`" ~ (!"`" ~ linechar)+ ~ "`")) }
----

====

|

Some text is `monospaced`.

[%collapsible]
.Html Output
====

[[inline_monospaced_html_output]]
[source, html]
----
<p>Some text is <code>monospaced</code>.</p>
----

====

|====

[%collapsible]
====
[[asciidoc_parser_functions]]
[source, rust]
----
fn process_inline<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::link => {
        base = process_link(element, base);
      }
      Rule::xref => {
        base = process_xref(element, base);
      }
      Rule::monospaced => {
        base.element = Element::Styled;
        base.attributes.push(Attribute {
          key: "style".to_string(),
          value: AttributeValue::Ref("monospaced"),
        });

        if let Some(content) = concat_elements(element.clone(), Rule::linechar, "") {
          base.attributes.push(Attribute {
            key: "content".to_string(),
            value: AttributeValue::String(content),
          });
        };
        for subelement in element.into_inner() {
          match subelement.as_rule() {
            Rule::inline_anchor => {
              base = process_inline_anchor(subelement, base);
            }
            _ => (),
          }
        }
      }
      Rule::strong => {
        base.element = Element::Styled;
        base.attributes.push(Attribute {
          key: "style".to_string(),
          value: AttributeValue::Ref("strong"),
        });

        if let Some(content) = concat_elements(element, Rule::linechar, "") {
          base.attributes.push(Attribute {
            key: "content".to_string(),
            value: AttributeValue::String(content),
          });
        };
      }
      Rule::emphasized => {
        base.element = Element::Styled;
        base.attributes.push(Attribute {
          key: "style".to_string(),
          value: AttributeValue::Ref("em"),
        });

        if let Some(content) = concat_elements(element, Rule::linechar, "") {
          base.attributes.push(Attribute {
            key: "content".to_string(),
            value: AttributeValue::String(content),
          });
        };
      }
      _ => (),
    };
  }
  base
}
----
====

== Listen
In Texten bieten sich Listen für alle Arten von Aufzählungen an.
Generell unterscheiden wir drei Arten von Listen:

* Unnummerierte Listen
* Nummerierte Listen
* Benannte Listen

[[blocks]]
[source, pest]
----
list = { bullet_list | numbered_list | labeled_list }
----

[[blocks]]
[source, pest]
----
list_element = ${
  (
    list_paragraph |
    (continuation ~ delimited_block)
  )+
}
list_paragraph = ${ (inline | other_list_inline)+ }
other_list_inline = @{ (!empty_lines ~ !EOI ~ !inline ~ !(NEWLINE ~ (bullet | number_bullet)) ~ !(continuation ~ delimited_block) ~ ANY)+ }
----

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::list => {
  for subelement in element.into_inner() {
    if let Some(e) = process_element(subelement, env) {
      base = e;
    }
  }
  Some(base)
}
Rule::list_paragraph => Some(process_paragraph(element)),
Rule::other_list_inline => Some(from_element(&element, Element::Text)),
Rule::continuation => None,
----

[[inline_elements]]
[source, pest]
----
continuation = { NEWLINE ~ "+" ~ NEWLINE }
----

====

=== Unnummerierte Listen
Unnummerierte Listen können mit `*` oder mit `-` erzeugt werden. Um eine
weitere Einrückung zu erzeugen kann man mehrere Punkte hintereinander
hängen (z.B. `**`).

[%collapsible]
====
[[blocks]]
[source, pest]
----
bullet = { ("*"+ | "-"+) }
bullet_list_element = { bullet ~ list_element ~ (NEWLINE | EOI) }
bullet_list = { bullet_list_element+ }
----
====

[cols="a,a"]
|====

[[unittest_bullet_list_input]]
[source, asciidoc, lisa-raw]
[output="bullet_list_html_output", name="bullet_list"]
....
* This
* is
* a
* list
** with subpoints
*** and deeper
**** nested subpoints
* Next normal point
....

|

* This
* is
* a
* list
** with subpoints
*** and deeper
**** nested subpoints
* Next normal point

[%collapsible]
.Html Output
====

[[bullet_list_html_output]]
[source, html]
----
<ul>
  <li>
    <p>This</p>
  </li>
  <li>
    <p>is</p>
  </li>
  <li>
    <p>a</p>
  </li>
  <li>
    <p>list</p>
    <ul>
      <li>
        <p>with subpoints</p>
        <ul>
          <li>
            <p>and deeper</p>
            <ul>
              <li>
                <p>nested subpoints</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Next normal point</p>
  </li>
</ul>
----
====

|

[[unittest_bullet_list_dashes_input]]
[source, asciidoc, lisa-raw]
[output="bullet_list_html_output", name="bullet_list_with_dashes"]
....
- This
- is
- a
- list
-- with subpoints
--- and deeper
---- nested subpoints
- Next normal point
....

|

- This
- is
- a
- list
-- with subpoints
--- and deeper
---- nested subpoints
- Next normal point

|====

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::bullet_list => {
  base.element = Element::List(ListType::Bullet);

  for subelement in element.into_inner() {
    if let Some(e) = process_element(subelement, env) {
      base.children.push(e);
    }
  }

  Some(base)
}
Rule::bullet_list_element => {
  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::bullet => {
        base.element = Element::ListItem(subelement.as_str().trim().len() as u32);
      }
      Rule::list_element => {
        for subelement in subelement.into_inner() {
          if let Some(e) = process_element(subelement, env) {
            base.children.push(e);
          }
        }
      }
      _ => {
        base.children.push(set_span(&subelement));
      }
    }
  }

  Some(base)
}
----

====

=== Nummerierte Listen
Manchmal möchte man die genaue Reihenfolge explizit vorgeben. In
diesem Fall verwendet man eine nummerierte Liste. Wir können die
Nummeriungspunkte mit `.` darstellen.

[%collapsible]
====
[[blocks]]
[source, pest]
----
number_bullet = { "."+ }
number_bullet_list_element = { number_bullet ~ list_element ~ (NEWLINE | EOI) }
numbered_list = { number_bullet_list_element+ }
----
====

[cols="a,a"]
|====

[[unittest_numbered_list_input]]
[source, asciidoc, lisa-raw]
[output="numbered_list_html_output", name="numbered_list"]
....
. This
. is
. a
.. nested
. numbered list
....

|

. This
. is
. a
.. nested
. numbered list

[%collapsible]
.Html Output
====

[[numbered_list_html_output]]
[source, html]
----
<ol class="arabic">
  <li>
    <p>This</p>
  </li>
  <li>
    <p>is</p>
  </li>
  <li>
    <p>a</p>
    <ol class="loweralpha" type="a">
      <li>
        <p>nested</p>
      </li>
    </ol>
  </li>
  <li>
    <p>numbered list</p>
  </li>
</ol>
----
====

|====

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::numbered_list => {
  base.element = Element::List(ListType::Number);

  for subelement in element.into_inner() {
    if let Some(e) = process_element(subelement, env) {
      base.children.push(e);
    }
  }

  Some(base)
}
Rule::number_bullet_list_element => {
  for subelement in element.into_inner() {
    match subelement.as_rule() {
      Rule::number_bullet => {
        base.element = Element::ListItem(subelement.as_str().trim().len() as u32);
      }
      Rule::list_element => {
        for subelement in subelement.into_inner() {
          if let Some(e) = process_element(subelement, env) {
            base.children.push(e);
          }
        }
      }
      _ => {
        base.children.push(set_span(&subelement));
      }
    }
  }

  Some(base)
}
----

====

=== Abhacklisten
TODO

=== Benannte Listen (Description Lists)
TODO

[[blocks]]
[source, pest]
----
label_bullet = { (!"::" ~ linechar) ~ "::" }
labeled_list = { (label_bullet ~ list_element)+ }
----

== Links
TODO

[[inline_elements]]
[source, pest]
----
link = ${ url ~ inline_attribute_list }
url = ${proto ~ "://" ~ path}
proto = ${ ("http" ~ "s"?) |
           "mailto" |
           "git"
         }
----

[%collapsible]
====

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_link<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  base.element = Element::Link;
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::url => {
        base.attributes.push(Attribute {
          key: "url".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
        let element = element.into_inner().next().unwrap(); // TODO Fehler möglich?
        base.attributes.push(Attribute {
          key: "protocol".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      Rule::inline_attribute_list => {
        base = process_inline_attribute_list(element, base);
      }
      _ => {
        base.children.push(set_span(&element));
      }
    };
  }
  base
}
----

====

== Querverweise
TODO

[[inline_elements]]
[source, pest]
----
xref = !{ "<<" ~ identifier ~ (NEWLINE? ~ "," ~ NEWLINE? ~ word+)? ~ ">>" }
----

[%collapsible]
====

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_xref<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
) -> ElementSpan<'a> {
  base.element = Element::XRef;
  for element in element.clone().into_inner() {
    match element.as_rule() {
      Rule::identifier => {
        base.attributes.push(Attribute {
          key: "id".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      Rule::word => {}
      _ => (),
    };
  }

  if let Some(content) = concat_elements(element, Rule::word, " ") {
    base.attributes.push(Attribute {
      key: "content".to_string(),
      value: AttributeValue::String(content),
    });
  };

  base
}
----

====

== Fußnoten
TODO

[[inline_elements]]
[source, pest]
----
footnote = { "footnote:" ~ inline_attribute_list }
footnoteref = { "footnoteref:" ~ inline_attribute_list }

quoted = @{ inline_attribute_list ~ "#" ~ (!"#" ~ linechar)+ ~ "#" }
----

== Bilder
Um Bilder einzubinden verwenden wir die übliche Syntax für Macros mit dem Schlüsselwort _image_.

[[blocks]]
[source, pest]
----
image_block = { anchor* ~ image }
image = { "image::" ~ (url | path) ~ inline_attribute_list }
----

[%collapsible]
====

[[asciidoc_element_rules]]
[source, rust]
----
Rule::image_block => Some(process_image(element, base, env)),
----

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_image<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
  env: &mut Env,
) -> ElementSpan<'a> {
  base.element = Element::Image;
  for element in element.into_inner().flatten() {
    match element.as_rule() {
      Rule::url => {
        base.attributes.push(Attribute {
          key: "path".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      Rule::path => {
        base.attributes.push(Attribute {
          key: "path".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      Rule::inline_attribute_list => {
        base = process_inline_attribute_list(element, base);
      }
      _ => (),
    };
  }

  if let Some(value) = base.get_attribute("opts") {
    if value == "inline" {
      if let Some(path) = base.get_attribute("path") {
        match env.read_to_string(path) {
          Ok(content) => {
            base.attributes.push(Attribute {
              key: "content".to_string(),
              value: AttributeValue::String(content),
            });
          }
          Err(e) => {
            error!("couldn't read content of image file {} ({})", path, e);
          }
        }
      } else {
        error!("There was no path of inline image defined");
      }
    }
  }

  base
}
----

====

== Tabellen
TODO

[[blocks]]
[source, pest]
----
delimited_table = {
  PUSH("|" ~ "="{3,}) ~ NEWLINE ~
  delimited_inner ~
  NEWLINE ~ POP ~ &(NEWLINE | EOI)
}

table_inner = {
  (table_row ~ NEWLINE*)+
}

table_row = {
  (!NEWLINE ~ table_cell)+
}

table_cell = {
  "|" ~ table_cell_content
}

table_cell_content = {
  (!"|" ~ !NEWLINE ~ ANY)*
}
----

[cols="a,a",separator="!"]
!===

[[unittest_simple_table_input]]
[source, asciidoc, lisa-raw]
[output="simple_table_html_output", name="simple_table"]
....
|===
| Col1 | Col2
| Cel1 | Cel2
| Cel3 | Cel4
|===
....

!

[separator="|"]
|===
| Col1 | Col2
| Cel1 | Cel2
| Cel3 | Cel4
|===

[%collapsible]
.Html Output
====

[[simple_table_html_output]]
[source, html]
----
<table class="tableblock frame-all grid-all stretch">
  <colgroup>
    <col style="width: 50%;">
    <col style="width: 50%;">
  </colgroup>
  <tbody>
    <tr>
      <td><p>Col1</p></td>
      <td><p>Col2</p></td>
    </tr>
    <tr>
      <td><p>Cel1</p></td>
      <td><p>Cel2</p></td>
    </tr>
    <tr>
      <td><p>Cel3</p></td>
      <td><p>Cel4</p></td>
    </tr>
  </tbody>
</table>
----
====

!===

[%collapsible]
====

[[delimited_block_rules]]
[source, rust]
----
Rule::delimited_table => {
  base.element = Element::Table;
  base = process_inner_table(subelement, base, env);
}
----

[[asciidoc_element_rules]]
[source, rust]
----
Rule::table_row => Some(process_table_row(element, base, env)),
Rule::table_cell => Some(process_table_cell(element, base, env)),
----

[[asciidoc_parser_functions]]
[source, rust]
----
fn process_inner_table<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
  env: &mut Env,
) -> ElementSpan<'a> {
  for element in element.into_inner() {
    match element.as_rule() {
      Rule::delimited_inner => {
        let ast = AsciidocParser::parse(Rule::table_inner, element.as_str()).unwrap();

        for element in ast {
          for subelement in element.into_inner() {
            if let Some(e) = process_element(subelement, env) {
              base.children.push(e);
            }
          }
        }
        base.attributes.push(Attribute {
          key: "content".to_string(),
          value: AttributeValue::Ref(element.as_str()),
        });
      }
      _ => (),
    };
  }
  base
}

fn process_table_row<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
  env: &mut Env,
) -> ElementSpan<'a> {
  base.element = Element::TableRow;
  for cell_element in element.into_inner() {
    let cell = process_table_cell(cell_element, base.clone(), env);
    base.children.push(cell);
  }
  base
}

fn process_table_cell<'a>(
  element: Pair<'a, asciidoc::Rule>,
  mut base: ElementSpan<'a>,
  _env: &mut Env,
) -> ElementSpan<'a> {
  base.element = Element::TableCell;
  base.content = element
    .into_inner()
    .find(|sub| sub.as_rule() == Rule::table_cell_content)
    .unwrap()
    .as_str()
    .trim();
  base
}
----

====

== Kommentare
Manchmal möchte man nur einen Kommentar für den Author eines Textes
(also meistens für sich selbst) festhalten, ohne dass dieser am Ende im
Dokument für den Leser erscheint. Asciidoc biete dazu Kommentare an.

[%collapsible]
====

[[inline_elements]]
[source, pest]
----
// TODO Damit werden keine Kommentare zu Beginn eines Paragraphen angezeigt
comment = { NEWLINE ~ "//" ~ (!NEWLINE ~ ANY)* ~ &NEWLINE }
----

[[blocks]]
[source, pest]
----
<<delimited_block_template|
    blocktype := "comment",
    delimiter := "/" >>
----

[[delimited_block_rules]]
[source, rust]
----
Rule::delimited_comment => {
  base.element = Element::TypedBlock {
    kind: BlockType::Comment,
  };
  base = process_delimited_inner(subelement, base, env);
}
----

====

== Quellcode Blöcke
Gerade Markup-Formate wie Asciidoc bieten sich an, um Quellcode Blöcke
einzubinden, da sie -- genauso wie Quelltext -- in reinen Textdateien
abgespeichert werden.

Sie können als abgetrennte Blöcke mit `-` oder `.` gekennzeichnet
werden.

[%collapsible]
====

[[blocks]]
[source, pest]
----
<<delimited_block_template|
    blocktype := "literal",
    delimiter := "." >>

<<delimited_block_template|
    blocktype := "source",
    delimiter := "-" >>
----

[[delimited_block_rules]]
[source, rust]
----
Rule::delimited_source => {
  base.element = Element::TypedBlock {
    kind: BlockType::Listing,
  };
  base = process_delimited_inner(subelement, base, env);
}
Rule::delimited_literal => {
  base.element = Element::TypedBlock {
    kind: BlockType::Listing,
  };
  base = process_delimited_inner(subelement, base, env);
}
----

====

[cols="a,a"]
|====

[[unittest_sourcecode_block_input]]
[source, asciidoc, lisa-raw]
[output="sourceblock_html_output", name="sourcecode_blocks"]
....
[source, bash]
----
echo "hello world!"
----
....

|

[source, bash]
----
echo "hello world!"
----

[%collapsible]
.Html Output
====

[[sourceblock_html_output]]
[source, html]
----
<div class="listingblock">
  <pre>echo "hello world!"</pre>
</div>
----
====

|

[[unittest_sourcecode_block_input]]
[source, asciidoc, lisa-raw]
[output="sourceblock_html_output", name="sourcecode_blocks"]
----
[source, bash]
....
echo "hello world!"
....
----

|

[source, bash]
....
echo "hello world!"
....

[%collapsible]
.Html Output
====

[[sourceblock_html_output]]
[source, html]
----
<div class="listingblock">
  <pre>echo "hello world!"</pre>
</div>
----
====

|====

== Beispiel Blöcke
Manchmal möchte man Inhalte als Beispiel kennzeichnen. Um das zu tun,
packt man den entsprechenden Inhalt in einen abgetrennten Block aus `=`
Zeichen.

[%collapsible]
====

[[blocks]]
[source, pest]
----
<<delimited_block_template|
    blocktype := "example",
    delimiter := "=" >>

delimited_verse = { "verse" } // TODO
----

[[delimited_block_rules]]
[source, rust]
----
Rule::delimited_example => {
  base.element = Element::TypedBlock {
    kind: BlockType::Example,
  };
  base = process_delimited_inner(subelement, base, env);
}
----

====

=== Einklappbare Blöcke
Einklappbare Blöcke sind nützlich, wenn man ergaenzende Informationen
nur bei Bedarf anzeigen möchte. So kann man die Informationen einbinden,
ohne dass der normale Leser überfordert wird.

[cols="a,a"]
|====

[[unittest_collapsible_input]]
[source, asciidoc, lisa-raw]
[output="collapsible_html_output", name="collapsible_blocks"]
....
[%collapsible]
====
Additional Information, that will only be shown on demand.
====
....

|

[%collapsible]
====
Additional Information, that will only be shown on demand.
====

[%collapsible]
.Html Output
====

[[collapsible_html_output]]
[source, html]
----
<details>
  <summary class="title">Details</summary>
  <div class="content">
    <div class="paragraph">
      <p>Additional Information, that will only be shown on demand.</p>
    </div>
  </div>
</details>
----
====

|
Blöcke können auch standardmäßig geöffnet sein.

[[unittest_collapsible_open_input]]
[source, asciidoc, lisa-raw]
[output="collapsible_open_html_output", name="collapsible_blocks_open"]
....
[%collapsible%open]
====
This Information is visible by default.
====
....

|

[%collapsible%open]
====
This Information is visible by default.
====

[%collapsible]
.Html Output
====
[[collapsible_open_html_output]]
[source, html]
----
<details open>
  <summary class="title">Details</summary>
  <div class="content">
    <div class="paragraph">
      <p>This Information is visible by default.</p>
    </div>
  </div>
</details>
----
====

|====

== Andere Dokumente einbinden
TODO

[[blocks]]
[source, pest]
----
include_macro = { "include::" ~ path ~ inline_attribute_list }
----

[[generic_pegs]]
[source, pest]
----
// TODO Should all unicode letters be matched? Instead of just ascii?
identifier = @{ (ASCII_ALPHANUMERIC | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-" | ".")* }

word = @{ (LETTER | NUMBER | "_" | "-")+ }
path = @{ (LETTER | NUMBER | "_" | "-" | "." | "/" | "~" )+ }

linechar = { (!NEWLINE ~ ANY) }

line = { linechar+ ~ ( &NEWLINE | &EOI) }

empty_lines = _{ NEWLINE{2, } | (NEWLINE ~ EOI) }
----

include::src/json-syntax.adoc[]

= Json

[source, rust, save]
.src/reader/json.rs
----
pub use crate::ast::*;
use crate::options::Opts;
use crate::util::{Env};
use crate::Result;

pub struct JsonReader {}

impl JsonReader {
  pub fn new() -> Self {
    JsonReader {}
  }
}

impl crate::Reader for JsonReader {
  fn parse<'a>(&self, input: &'a str, _args: &Opts, _env: &mut Env) -> Result<AST<'a>> {
    let ast = serde_json::from_str(input)?;

    Ok(ast)
  }
}
----

:leveloffset: -3

[[output-format]]
=== Ausgabeformate
Der ganze Sinn des Programmes besteht darin, aus einer einzigen Datenquelle
verschiedene Ausgabedateien zu erzeugen. Diese können noch eigenen
Vorstellungen oder Vorgaben formatiert und abgelegt werden. `asciidoctrine`
unterstützt verschiedene Ausgabeformate, die in den folgenden Abschnitten
beschrieben werden (sowie wie man Formatierungsanpassungen vornehmen kann)

[source, rust, save]
.src/writer/mod.rs
----
pub mod html;
pub mod docx;
pub mod json;
----

:leveloffset: +3

include::src/output/html5.adoc[]

[[html5]]
= Html5

[source, rust, save]
.src/writer/html.rs
----
pub use crate::ast::*;
use crate::util::Environment;
use crate::{options, Result, AsciidoctrineError};
use std::io;
use tera::{Context, Tera};

pub struct HtmlWriter {
  io: crate::util::Env,
}

impl HtmlWriter {
  pub fn new() -> Self {
    HtmlWriter {
      io: crate::util::Env::Io(crate::util::Io::new()),
    }
  }
}

impl<T: io::Write> crate::Writer<T> for HtmlWriter {
  fn write<'a>(&mut self, ast: AST, args: &options::Opts, mut out: T) -> Result<()> {
    let mut buf = io::BufWriter::new(Vec::new());

    for element in ast.elements.iter() {
      write_html(element, 0, &mut buf)?;
    }
    let bytes = buf.into_inner()?;

    let mut context = Context::new();
    context.insert("lang", "en");
    context.insert("doctitle", "");
    match &args.stylesheet {
      Some(path) => {
        let path = path.to_str().expect("path to stylesheet unreadable");
        let stylesheet = self.io.read_to_string(path)?;
        context.insert("stylesheet", &stylesheet);
      }
      None => {
        context.insert("stylesheet", include_str!("assets/asciidoctor.css"));
      }
    }
    context.insert("body_class", "article toc2 toc-left");
    context.insert("body", std::str::from_utf8(&bytes)?);

    let mut tera = Tera::default();
    tera.autoescape_on(vec![]);
    match &args.template {
      Some(path) => {
        let path = path.to_str().expect("path to stylesheet unreadable");
        let template = if path == "-" {
          "{{body}}".to_string()
        } else {
          self.io.read_to_string(path)?
        };
        tera
          .add_raw_template("default.html", &template)
          .expect("couldn't load default template");
      }
      None => {
        tera
          .add_raw_template("default.html", include_str!("assets/template.html"))
          .expect("couldn't load default template");
      }
    }
    out.write_all(tera.render("default.html", &context)?.as_bytes())?;
    out.flush()?;

    Ok(())
  }
}

fn write_html<T: io::Write>(input: &ElementSpan, indent: usize, out: &mut T) -> Result<()> {
  match &input.element {
    <<format_html_element>>
    Element::Text => {
      out.write_all(input.content.as_bytes())?;
    }
    Element::Styled => {
      let style = match input.get_attribute("style").unwrap_or("") {
        "monospaced" => "code",
        style => style,
      };
      write_tag(style, input, indent, out)?;
    }
    _ => {
      out.write_all(
        &format!(
          "<NOT-YET-SUPPORTED:{:?}>{}</NOT-YET-SUPPORTED:{:?}>\n",
          input.element, input.content, input.element,
        )
        .as_bytes(),
      )?;
    }
  }

  Ok(())
}

// Helper Functions
//----------------------------------------------------

fn escape_text(input: &str) -> String {
  input.replace("<", "&lt;").replace(">", "&gt;")
}

fn write_tag<T: io::Write>(
  tag: &str,
  inner: &ElementSpan,
  indent: usize,
  out: &mut T,
) -> Result<()> {
  write_attribute_tag(tag, "", inner, indent, out)
}

fn write_attribute_tag<T: io::Write>(
  tag: &str,
  attrs: &str,
  inner: &ElementSpan,
  indent: usize,
  out: &mut T,
) -> Result<()> {
  write_open_attribute_tag(tag, attrs, indent, out)?;

  match &inner.element {
    Element::Title { .. } => {
      let title = inner
        .get_attribute("name")
        .ok_or(AsciidoctrineError::MalformedAst)?;
      out.write_all(title.as_bytes())?;
    }
    Element::Paragraph => {
      for element in inner.children.iter() {
        write_html(element, indent, out)?;
      }
    }
    Element::Styled => {
      let content = inner.get_attribute("content").unwrap_or("");
      out.write_all(content.as_bytes())?;
    }
    <<format_html_enclosed_element>>
    el => write_html(inner, indent + 1, out)?,
  };

  out.write_all(format!("</{}>", tag).as_bytes())?;
  Ok(())
}

fn write_open_tag<T: io::Write>(tag: &str, indent: usize, out: &mut T) -> Result<()> {
  write_open_attribute_tag(tag, "", indent, out)
}

fn write_open_attribute_tag<T: io::Write>(
  tag: &str,
  attrs: &str,
  indent: usize,
  out: &mut T,
) -> Result<()> {
  out.write_all(&b"  ".repeat(indent))?;
  out.write_all(format!("<{}", tag).as_bytes())?;
  if attrs != "" {
    out.write_all(b" ")?;
    out.write_all(attrs.as_bytes())?;
  }
  out.write_all(b">")?;
  Ok(())
}

fn write_close_tag<T: io::Write>(tag: &str, indent: usize, out: &mut T) -> io::Result<()> {
  out.write_all(&b"  ".repeat(indent))?;
  out.write_all(format!("</{}>", tag).as_bytes())
}

fn write_open_tag_ln<T: io::Write>(tag: &str, indent: usize, out: &mut T) -> Result<()> {
  write_open_tag(tag, indent, out)?;
  out.write_all(b"\n")?;
  Ok(())
}

fn write_open_attribute_tag_ln<T: io::Write>(
  tag: &str,
  attrs: &str,
  indent: usize,
  out: &mut T,
) -> Result<()> {
  write_open_attribute_tag(tag, attrs, indent, out)?;
  out.write_all(b"\n")?;
  Ok(())
}

fn write_close_tag_ln<T: io::Write>(tag: &str, indent: usize, out: &mut T) -> io::Result<()> {
  write_close_tag(tag, indent, out)?;
  out.write_all(b"\n")
}
----

== Überschriften

[[format_html_element]]
[source, rust]
----
Element::Title { level } => {
  let tag = format!("h{}", level);

  if level > &1 {
    let id = match input.get_attribute("anchor") {
      Some(id) => id.to_string(),
      None => {
        let title = input
          .get_attribute("name")
          .ok_or(AsciidoctrineError::MalformedAst)?;
        "_".to_string() + &title.replace(" ", "_").to_lowercase()
      }
    };
    let attrs = format!("id=\"{}\"", id);
    write_attribute_tag(&tag, &attrs, input, indent, out)?;
  } else {
    write_tag(&tag, input, indent, out)?;
  };
  out.write_all(b"\n")?;
}
----

== Absätze

[[format_html_element]]
[source, rust]
----
Element::Paragraph => {
  write_tag("p", input, indent, out)?;
  out.write_all(b"\n")?;
}
----

== Listen

[[format_html_element]]
[source, rust]
----
Element::List(list_type) => {
  let list_element = match list_type {
    ListType::Bullet => "ul",
    ListType::Number => "ol",
  };

  let mut current_level = 0;
  for element in input.children.iter() {
    if let Element::ListItem(item_level) = element.element {
      let attrs = match list_type {
        ListType::Bullet => "",
        ListType::Number => {
          if item_level % 2 == 0 {
            "class=\"loweralpha\" type=\"a\""
          } else {
            "class=\"arabic\""
          }
        }
      };

      let item_level = item_level as usize;
      let offset = if current_level > 0 { item_level - 1 } else { 0 };
      if current_level < item_level {
        write_open_attribute_tag_ln(list_element, attrs, indent + current_level + offset, out)?;
        write_open_tag_ln("li", indent + item_level + offset, out)?;
      } else {
        if current_level > item_level {
          let diff = current_level - item_level;
          let offset = (current_level * 2) - 1;
          for i in 0..diff {
            write_close_tag_ln("li", indent + offset - (2 * i), out)?;
            write_close_tag_ln(list_element, indent + offset - (2 * i) - 1, out)?;
          }
        }
        write_close_tag_ln("li", indent + item_level, out)?;
        write_open_tag_ln("li", indent + item_level, out)?;
      }
      write_html(element, indent + item_level + offset, out)?;

      current_level = item_level;
    }
  }
  write_close_tag_ln("li", indent + 1, out)?;
  write_close_tag_ln(list_element, indent, out)?;
}
Element::ListItem(_) => {
  for element in input.children.iter() {
    write_html(element, indent + 1, out)?;
  }
}
----

== Sourcecode Blocke

[[format_html_element]]
[source, rust]
----
Element::TypedBlock { kind } => {
  if kind == &BlockType::Comment {
    // Comments are not printed in html
    // TODO provide option to print comments
    return Ok(());
  }
  if kind == &BlockType::Example &&
      input.positional_attributes.iter()
        .find(
          |&attr| attr.as_str().find("%collapsible").is_some()
        ).is_some()
  {
    if input.positional_attributes.iter()
      .find(
        |&attr| attr.as_str().find("%open").is_some()
      ).is_some()
    {
      write_open_tag("details open", indent, out)?;
    } else {
      write_open_tag("details", indent, out)?;
    }

    let title = input.get_attribute("title").unwrap_or("Details");
    out.write_all(&format!("\n  <summary class=\"title\">{}</summary>\n", title).as_bytes())?;

    write_open_tag_ln("div class=\"content\"", indent + 1, out)?;
    write_open_tag_ln("div class=\"paragraph\"", indent + 2, out)?;
    for element in input.children.iter() {
      write_html(element, indent + 3, out)?;
    }
    write_close_tag_ln("div", indent + 2, out)?;
    write_close_tag_ln("div", indent + 1, out)?;
    write_close_tag_ln("details", indent, out)?;

    return Ok(());
  }

  out.write_all(b"<div")?;

  if let Some(id) = input.get_attribute("anchor") {
    out.write_all(&format!(" id=\"{}\" ", id).as_bytes())?;
  };

  let class = match kind {
    BlockType::Listing => "listingblock",
    _ => "unknown-block",
  };
  out.write_all(&format!(" class=\"{}\">\n", class).as_bytes())?;

  if let Some(title) = input.get_attribute("title") {
    out.write_all(&format!("\n  <div class=\"title\">{}</div>\n", title).as_bytes())?;
  };

  if kind == &BlockType::Listing {
    out.write_all(b"  <pre>")?;
  }

  let content = input.get_attribute("content").unwrap_or(input.content);
  out.write_all(escape_text(&content).as_bytes())?;

  if kind == &BlockType::Listing {
    out.write_all(b"</pre>\n")?;
  }
  write_close_tag_ln("div", indent, out)?;
}
----

== Links

[[format_html_element]]
[source, rust]
----
Element::Link => {
  let url = input.get_attribute("url").unwrap_or("");
  let content = match input.positional_attributes.get(0) {
    Some(value) => match value {
      AttributeValue::Ref(value) => value.to_string(),
      AttributeValue::String(value) => value.clone(),
    },
    None => "".to_string(),
  };

  out.write_all(&format!("<a href=\"{}\">{}</a>", url, content).as_bytes())?;
}
----

== Querverweise

[[format_html_element]]
[source, rust]
----
Element::XRef => {
  let id = input.get_attribute("id").unwrap_or("");
  let content = input.get_attribute("content").unwrap_or(id.clone());

  out.write_all(&format!("<a href=\"#{}\">{}</a>", id, content).as_bytes())?;
}
----

== Fußnoten
TODO

== Bilder

TODO Bilder einbetten, entweder als Daten oder z.B. direkt als svg.
TODO Fehler wenn keine Attribute vorhanden sind

[[format_html_element]]
[source, rust]
----
Element::Image => {
  if let Some(path) = input.get_attribute("path") {
    match input.get_attribute("opts") {
      Some(options) => {
        let content = input.get_attribute("content").unwrap_or("");
        if options == "inline" {
          if path.ends_with(".svg") {
            out.write_all(content.as_bytes())?;
          }
          // TODO
        } else if options == "interactive" {
          // TODO
        } else {
          // TODO
        }
      }
      None => {
        out.write_all(&format!("<img src=\"{}\"></div>\n", path).as_bytes())?;
      }
    }
  }
}
----

== Tabellen
TODO

[[format_html_element]]
[source, rust]
----
Element::Table => {
  write_open_attribute_tag_ln("table", "class=\"tableblock frame-all grid-all stretch\"", indent, out)?;
  write_open_tag_ln("colgroup", indent+1, out)?;
  write_open_attribute_tag_ln("col", "style=\"width: 50%;\"", indent+2, out)?;
  write_open_attribute_tag_ln("col", "style=\"width: 50%;\"", indent+2, out)?;
  write_close_tag_ln("colgroup", indent+1, out)?;
  write_open_tag_ln("tbody", indent+1, out)?;
  for table_row in input.children.iter() {
    match &table_row.element {
        Element::TableRow => {
          write_open_tag_ln("tr", indent+2, out)?;
          for table_cell in table_row.children.iter() {
              match &table_cell.element {
                  Element::TableCell => {
                    write_tag("td", table_cell, indent+3, out)?;
                  }
                  _ => (),
              }
              out.write_all(b"\n")?;
          }
          write_close_tag_ln("tr", indent+2, out)?;
        }
        _ => {
          out.write_all(
            &format!(
              "<NOT-YET-SUPPORTED:{:?}>{}</NOT-YET-SUPPORTED:{:?}>\n",
              table_row.element, table_row.content, table_row.element,
            )
            .as_bytes(),
          )?;
        },
    }
  }
  write_close_tag_ln("tbody", indent+1, out)?;
  write_close_tag_ln("table", indent, out)?;
}
----

[[format_html_enclosed_element]]
[source, rust]
----
Element::TableCell => {
  write_open_tag("p", 0, out)?;
  out.write_all(inner.content.as_bytes())?;
  write_close_tag("p", 0, out)?;
}
----

== Inhaltsverzeichnis
TODO

include::src/output/docbook.adoc[]
include::src/output/manpage.adoc[]
include::src/output/pdf.adoc[]
include::src/output/json-ast.adoc[]

= Json

[source, rust, save]
.src/writer/json.rs
----
pub use crate::ast::*;
use crate::{options, Result};
use std::io;

pub struct JsonWriter {}

impl JsonWriter {
  pub fn new() -> Self {
    JsonWriter {}
  }
}

impl<T: io::Write> crate::Writer<T> for JsonWriter {
  fn write<'a>(&mut self, ast: AST, _args: &options::Opts, mut out: T) -> Result<()> {
    out.write_all(serde_json::to_string_pretty(&ast)?.as_bytes())?;
    out.flush()?;

    Ok(())
  }
}
----

:leveloffset: -3

== asciidoctrine in andere Programme einbinden
TODO

[[cmd-api]]
=== Aufruf auf der Kommandozeile
Der einfachste Weg asciidoctrine in ein anderes Programm einzubinden ist es über der Kommandozeile aufzurufen.

[source, rust, save]
.src/options.rs
----
use clap::{Parser, ValueEnum};
use std::path::PathBuf;

/// Parse a single key-value pair
fn parse_key_val<T, U>(s: &str) -> Result<(T, U), String>
where
  T: std::str::FromStr,
  U: std::str::FromStr,
{
  let pos = s
    .find('=')
    .ok_or_else(|| format!("invalid KEY=value: no `=` found in `{}`", s))?;
  let key = s[..pos]
    .parse()
    .or_else(|_| Err(format!("couldn't parse key in `{}`", s)))?;
  let value = s[pos + 1..]
    .parse()
    .or_else(|_| Err(format!("couldn't parse value in `{}`", s)))?;
  Ok((key, value))
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Debug)]
pub enum Reader {
  Asciidoc,
  Json,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Debug)]
pub enum Writer {
  Html5,
  Docbook,
  Pdf,
  Json,
  Docx,
  // The asciidoc output makes it possible
  // to use this tool as a preprocessor for
  // other asciidoc tools while it is maturing
  Asciidoc,
}

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
pub struct Opts {
  #[clap(short = 'r', long = "reader-format", default_value_t = Reader::Asciidoc)]
  #[clap(value_enum)]
  pub readerfmt: Reader,
  #[clap(short = 'w', long = "writer-format", default_value_t = Writer::Html5)]
  #[clap(value_enum)]
  pub writerfmt: Writer,
  #[clap(short = 'e', long = "extension")]
  pub extensions: Vec<String>,
  #[clap(long)]
  pub template: Option<PathBuf>,
  #[clap(long)]
  pub stylesheet: Option<PathBuf>,
  #[clap(short = 'a', long = "attribute")]
  #[clap(value_parser = parse_key_val::<String, String>, number_of_values = 1)]
  defines: Vec<(String, String)>,
  #[clap(name = "FILE")]
  pub input: Option<PathBuf>,
  #[clap(short = 'o')]
  pub output: Option<PathBuf>,
}

pub fn from_args() -> Opts {
  Opts::parse()
}
----

[[extensions]]
== asciidoctrine erweitern
Man kann `asciidoctrine` über eine api Schnittstelle erweitern. Dazu werden für alle wichtigen Funktionen Schnittstellen definiert, welche von der jeweiligen Erweiterung implementiert werden müssen.

[[reader]]
=== Neue Datenformate einlesen
Jedes Eingabeformat muss zunächst in einen <<ast, Abstract Syntax Tree>> ungewandelt werden um von asciidoctrine verarebitet werden zu können. Auch alle intern unterstützten Dateiformate implementieren die gleiche Schnittstelle.

[[interfaces]]
[source, rust]
----
pub trait Reader {
  fn parse<'a>(&self, input: &'a str, args: &options::Opts, env: &mut util::Env) -> Result<AST<'a>>;
}
----

[[extension]]
=== Den AST verarbeiten/modifizieren
Manchmal will man den <<ast, Abstract Syntax Tree>> verarbeiten und daraus Informationen nutzen (<<../lisa.adoc#, lisa>> verwendet ihn z.B. um daraus Quelltext-Dateien zu extrahieren). Das ermöglicht sehr viele Anwendungsfälle:

* Daten extrahieren und Prüfungen oder Statistiken damit durchführen
* Rechtschreibprüfung durchführen
* Mehrere Dokumente vereinen
* etc

Für alle diese Funktionen definieren wir eine Schnittstelle welche einen AST einließt und am Ende einen AST ausgibt. Wie er zwischendurch verarbeitet wird und ob er modifiziert wird bleibt vollständig der Erweiterung überlassen.

[[interfaces]]
[source, rust]
----
pub trait Extension {
  // TODO Options (Kann auch über Attributes in AST gemacht werden)
  fn transform<'a>(&mut self, input: AST<'a>) -> anyhow::Result<AST<'a>>;
}
----

[[writer]]
=== Neue Ausgabeformate unterstützen
Um ein weiteres Ausgabeformat zu implementieren muss die entsprechende Schnittstelle implementiert werden. Sie konsumiert einen <<ast, AST>> und ist dafür verantwortlich eine Datei zu erstellen, welche das Ausgabeformat verwendet.

[[interfaces]]
[source, rust]
----
pub trait Writer<T: io::Write> {
  // TODO Result zurückgeben mit Fehler oder Liste der Geschriebenen Dateien
  fn write<'a>(&mut self, ast: AST, args: &options::Opts, out: T) -> Result<()>;
}
----

[[ast]]
=== Der Abstract Syntax Tree
Alle Schnittstellen basieren auf der gleichen Datenstrucktur. Diese bildet ein Dokument vollständig ab.

[source, rust, save]
.src/ast.rs
----
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct AST<'a> {
  pub content: &'a str,
  pub elements: Vec<ElementSpan<'a>>,
  pub attributes: Vec<Attribute<'a>>,
}

<<ast_structs>>
----

[[ast_structs]]
[source, rust]
----
impl AST<'_> {
  pub fn get_attribute(&self, name: &str) -> Option<&str> {
    for attribute in self.attributes.iter() {
      if &attribute.key == name {
        return match &attribute.value {
          AttributeValue::Ref(value) => Some(value),
          AttributeValue::String(value) => Some(value.as_str()),
        };
      }
    }

    None
  }
}

/// The basic element of a document
///
/// This is meant to form a tree of document element.
/// Every element holds references to its source, it
/// subelements and the attributes defined on it.
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct ElementSpan<'a> {
  // The source document. Could be empty if
  // e.g. it's the same as the source of it's
  // parent
  pub source: Option<String>,
  // A string reference to the source
  pub content: &'a str,
  // TODO Add start and end point
  pub start: usize,
  pub end: usize,
  /// We count the lines for usage in other tools
  pub start_line: usize,
  pub start_col: usize,
  pub end_line: usize,
  pub end_col: usize,

  pub element: Element<'a>,
  /// The subelements of a nodes
  pub children: Vec<ElementSpan<'a>>,
  /// The attributes applying to that node and
  /// all children
  pub positional_attributes: Vec<AttributeValue<'a>>,
  /// The attributes applying to that node and
  /// all children
  pub attributes: Vec<Attribute<'a>>,
}

impl ElementSpan<'_> {
  pub fn get_attribute(&self, name: &str) -> Option<&str> {
    for attribute in self.attributes.iter() {
      if &attribute.key == name {
        return match &attribute.value {
          AttributeValue::Ref(value) => Some(value),
          AttributeValue::String(value) => Some(value.as_str()),
        };
      }
    }

    None
  }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub enum Element<'a> {
  Attribute(#[serde(borrow)] Attribute<'a>),
  /// A section of ignored text
  Comment,
  /// A text paragraph
  Paragraph,
  /// A header section
  Title {
    level: u32,
  },
  Table,
  List(ListType),
  Image,
  Anchor,
  /// Holds all blocks with special content and the type
  /// TODO Could be done with ExternalContent and all known
  /// Types here direktly
  TypedBlock {
    kind: BlockType,
  },
  /// Holds content which is not przessed direktly by
  /// asciidoctrine. It can be anything. Outputs or
  /// postprocessors could use or ignore it at their
  /// will (e.g. videos)
  ExternalContent,
  /// Holds a reference to the include statement
  /// and a document inside
  IncludeElement(IncludeElement<'a>),

  /// The following variants are inline elements nested
  /// inside a conainer element

  /// Element with a special style. The attributes define the kind of style
  Styled,
  /// A chunk of text.
  Text,
  /// An internal reference or link
  XRef,
  /// An external link
  Link,
  /// A list item
  ListItem(u32),
  /// A table row
  TableRow,
  /// A table cell
  TableCell,
  /// A wrong formatted text or block
  Error(String),
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub enum ListType {
  Bullet,
  Number,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub enum BlockType {
  Comment,
  Passtrough,
  Listing,
  Literal,
  Sidebar,
  Quote,
  Example,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub enum AttributeValue<'a> {
  String(String),
  Ref(&'a str),
}

impl AttributeValue<'_> {
  pub fn as_str(&self) -> &str {
    match self {
      AttributeValue::Ref(value) => value,
      AttributeValue::String(value) => value.as_str(),
    }
  }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct Attribute<'a> {
  pub key: String,
  #[serde(borrow)]
  pub value: AttributeValue<'a>,
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct IncludeElement<'a> {
  #[serde(borrow)]
  pub inner: AST<'a>,
}
----

Jedes Dokument ist im Großen und Ganzen eine Ansammlung von hintereinander liegenden Strukturelementen (wie Überschriften, Texten, etc). In unserem Fall hat ein Dokument zusätzlich noch Eigenschaften welche ihm zugewiesen werden können.

== tmp Implementierung

[%collapsible]
====

Im Fehlerfall ist es nicht immer gut gleich das Programm zu beenden. Damit der Benutzer dennoch darauf reagieren kann geben wir bei Bedarf log-Meldungen aus. Dazu benötigen wir den entspechenden Crate.

[[crate_usages]]
[source, rust]
----
#[macro_use]
extern crate log;
----

[source, rust, save]
.src/util.rs
----
use std::collections::HashMap;
use std::fs;
use std::io::{self, ErrorKind, Write};
use std::path::Path;
use std::process::{Command, Stdio};

pub trait Environment {
  fn read_to_string(&mut self, path: &str) -> crate::Result<String>;
  fn write(&mut self, path: &str, content: &str) -> crate::Result<()>;
  fn eval(&mut self, interpreter: &str, content: &str) -> crate::Result<(bool, String, String)>; // success, Stdout, Stderr
}

pub struct Io {}

impl Io {
  pub fn new() -> Self {
    Io {}
  }
}

impl Environment for Io {
  fn read_to_string(&mut self, path: &str) -> crate::Result<String> {
    Ok(fs::read_to_string(path)?)
  }

  fn write(&mut self, path: &str, content: &str) -> crate::Result<()> {
    let path = Path::new(path);
    if let Some(path) = path.parent() {
      if !path.exists() {
        fs::create_dir_all(path)?;
      }
    }

    if path.exists() {
      let old_content = fs::read_to_string(path)?;
      if old_content == content {
        return Ok(());
      }
    }
    fs::write(path, content)?;

    Ok(())
  }

  fn eval(&mut self, interpreter: &str, content: &str) -> crate::Result<(bool, String, String)> {
    let mut eval = Command::new(interpreter)
      .stdin(Stdio::piped())
      .stderr(Stdio::piped())
      .stdout(Stdio::piped())
      .spawn()?;

    eval
      .stdin
      .as_mut()
      .ok_or(crate::AsciidoctrineError::Childprocess)?
      .write_all(content.as_bytes())?; // TODO Wie soll EOF gesendet werden?
    let output = eval.wait_with_output()?;

    let success = output.status.success();
    let out = match String::from_utf8(output.stdout) {
      Ok(out) => out,
      Err(_) => "Error: Couldn't decode stdout".to_string(),
    };
    let err = match String::from_utf8(output.stderr) {
      Ok(out) => out,
      Err(_) => "Error: Couldn't decode stderr".to_string(),
    };

    Ok((success, out, err))
  }
}

pub struct Cache {
  files: HashMap<String, String>,
  evaluations: HashMap<(String, String),(
    bool,
    String,
    String,
    Vec<(String, String)>,
    Vec<String>)>,
}

impl Cache {
  pub fn new() -> Self {
    Cache {
      files: HashMap::default(),
      evaluations: HashMap::default(),
    }
  }

  pub fn get_files(self) -> HashMap<String, String> {
    self.files
  }
}

impl Environment for Cache {
  fn read_to_string(&mut self, path: &str) -> crate::Result<String> {
    Ok(self.files.remove(path).ok_or(io::Error::new(
      ErrorKind::NotFound,
      "file not found in cache",
    ))?)
  }

  fn write(&mut self, path: &str, content: &str) -> crate::Result<()> {
    self.files.insert(path.to_string(), content.to_string());

    Ok(())
  }

  fn eval(&mut self, interpreter: &str, content: &str) -> crate::Result<(bool, String, String)> {
    match self.evaluations.remove(
      &(interpreter.to_string(), content.to_string()))
    {
      Some((success, out, err, add, remove)) => {
        for path in remove.iter() {
          self.files.remove(path);
        }
        for (path, content) in add.into_iter() {
          self.files.insert(path, content);
        }
        Ok((success, out, err))
      }
      None => Err(crate::AsciidoctrineError::Childprocess)
    }
  }
}

pub enum Env {
  Io(Io),
  Cache(Cache),
}

impl Env {
  pub fn get_cache(self) -> Option<HashMap<String, String>> {
    match self {
      Env::Io(_) => None,
      Env::Cache(env) => Some(env.get_files()),
    }
  }
}

impl Environment for Env {
  fn read_to_string(&mut self, path: &str) -> crate::Result<String> {
    match self {
      Env::Io(env) => env.read_to_string(path),
      Env::Cache(env) => env.read_to_string(path),
    }
  }

  fn write(&mut self, path: &str, content: &str) -> crate::Result<()> {
    match self {
      Env::Io(env) => env.write(path, content),
      Env::Cache(env) => env.write(path, content),
    }
  }

  fn eval(&mut self, interpreter: &str, content: &str) -> crate::Result<(bool, String, String)> {
    match self {
      Env::Io(env) => env.eval(interpreter, content),
      Env::Cache(env) => env.eval(interpreter, content),
    }
  }
}
----

====

== Installation
TODO

== Build
TODO

== Tests

=== Testumgebung
Um `asciidoctrine` zu testen verwenden wir die im Userguide
beschriebenen Beispiele.

Der generelle Aufbau eines Tests ist:

[[unit-test-template]]
[source, rust]
.Grundlegender Aufbau eines Unit Tests
----
#[test]
fn {test_name}() -> Result<()> {
  let content = r#"{asciidoc_content}"#;
  let reader = AsciidocReader::new();
  let mut opts = options::Opts::parse_from(vec!["--template", "-"].into_iter());
  let mut env = util::Env::Cache(util::Cache::new());
  let ast = reader.parse(content, &opts, &mut env)?;

  let mut buf = BufWriter::new(Vec::new());
  let mut writer = HtmlWriter::new();
  writer.write(ast, &opts, &mut buf)?;

  let output = String::from_utf8(buf.into_inner()?)?;
  assert_eq!(
    output,
    r#"{expected_content}"#
  );

  Ok(())
}
----

Anschließend packen wir alle Tests in eine Datei:

[source, rust, save]
.tests/asciidoc_to_html_test.rs
----
use anyhow::Result;
use asciidoctrine::{self, *};
use clap::Parser;
use pretty_assertions::assert_eq;
use std::io::BufWriter;

<<html-unit-tests>>
----

Um die Tests zu erzeugen gehen wir alle Beispiele im Userguide durch,
welche mit entsprechenden Attributen gekennzeichnet wurden.

[[html-unit-tests]]
[source, js, pipe]
----
let template = lisa.get_snippet("unit-test-template").content;
let tests = "";

for name in lisa.get_snippet_names() {
  if name.contains("unittest_") && name.contains("_input") {
    let out_template = template;
    let compare_out = "";

    let snippet = lisa.get_snippet(name);
    out_template.replace("{test_name}", snippet.attrs.name);
    let asciidoc_content = "\n" + snippet.content + "\n";
    asciidoc_content.replace(" -- <1>", "");
    asciidoc_content.replace(" -- <2>", "");
    out_template.replace("{asciidoc_content}", asciidoc_content);

    let output_snippet = lisa.get_snippet(snippet.attrs.output);
    out_template.replace("{expected_content}", output_snippet.content + "\n");

    tests += out_template;
    tests += "\n\n";
  }
}

lisa.store("html-unit-tests", tests);
----

== Verwandte Projekte
Es gibt einige Projekte mit vergleichbaren Zielen und teilweise auch einer vergleichbaren Architektur wie asciidoctrine.

* asciidoc TODO
* http://asciidoctor.org[asciidoctor] ist der Standard um asciidoc Dokumente zu rendern. Es ist in ruby geschrieben. Da der interne AST aber nicht direkt manipulierbar ist (obwohl es natürlich Möglichkeiten für Erweiterungen und auch viele tolle Plugins gibt) scheint es mir nicht ganz so flexibel wie asciidoctrine zu sein.
* http://jgm.github.io/lunamark/doc/lunamark.html[lunamark] wurde ja bereits in der Einleitung erwähnt. Es war eine große Quelle der Inspiration für dieses Projekt.
* https://pandoc.org/[Pandoc] ist ein Projekt mit einem sehr ähnlichen Aufbau. Es ist eine großartige Software und kommt vom gleichen Autor wie lunamark. Es wurde in Haskell geschrieben. Der große Unterschied (und auch der Grund, warum ich die Ziele von asciidoctrine nicht damit erreichen kann) ist, dass es einen https://hackage.haskell.org/package/pandoc-types/docs/Text-Pandoc-Definition.html[simpleren AST] benutzt (denn die Ausgangssprache ist hier Markdown). Daher kann es einiges nicht abbilden was ich gerne in Dokumenten verwende.

